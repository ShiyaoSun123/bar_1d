import numpy as np
######################################################################################################################
######################################################################################################################

def guass_1d(nipt):  # input:number of integration points up to 6
    if nipt == 1:
        wts = np.array([2])
        xk = np.array([0])
        return wts, xk

    if nipt == 2:
        wts = np.array([1, 1])
        xk = np.array([-0.5773502691896257, 0.5773502691896257])
        return wts, xk

    if nipt == 3:
        wts = np.array([0.8888888888888888, 0.5555555555555556, 0.5555555555555556])
        xk = np.array([0.0000000000000000, -0.7745966692414834, 0.7745966692414834])
        return wts, xk

    if nipt == 4:
        wts = np.array([0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538])
        xk = np.array([-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526])
        return wts, xk

    if nipt == 5:
        wts = np.array(
            [0.5688888888888889, 0.4786286704993665, 0.4786286704993665, 0.2369268850561891, 0.2369268850561891])
        xk = np.array(
            [0.0000000000000000, -0.5384693101056831, 0.5384693101056831, -0.9061798459386640, 0.9061798459386640])
        return wts, xk

    if nipt == 6:
        wts = np.array(
            [0.3607615730481386, 0.3607615730481386, 0.4679139345726910, 0.4679139345726910, 0.1713244923791704,
             0.1713244923791704])
        xk = np.array(
            [0.6612093864662645, -0.6612093864662645, -0.2386191860831969, 0.2386191860831969, -0.9324695142031521,
             0.9324695142031521])
        return wts, xk


##########################################################################################################################
##########################################################################################################################

def mesh_gen(L, nele, order):
    # generate external nodes coordinates
    coord_ext = np.linspace(0, L, nele+1)
    dx = L/nele/order
    coord_int = np.arange(0, L+dx, dx)
    coord_int = np.delete(coord_int, np.arange(0, coord_int.size, order))

    coord = np.append(coord_ext, coord_int)


    conn = np.zeros((order+1,nele), dtype=np.int32)
    conn[0][0] = 0
    conn[1][0] = 1

    for k in range(2, order+1):
        conn[k][0] = nele + k - 1

    for i in range(order+1):
        for j in range(1, nele):
            if i <= 1:
                conn[i, j] = conn[i, j - 1] + 1

            else:
                conn[i, j] = conn[i, j-1] + order -1
    return coord, conn

##########################################################################################################################
##########################################################################################################################
def shape_fun(z, order, xe):   #xe input as column vector
    if order == 1:
        N = np.array([0.5*(1-z), 0.5*(1+z)])
        jac = np.array([-0.5, 0.5]) @ xe
        dN_dx = np.array([-0.5, 0.5])/jac

        return N, dN_dx, jac

    if order == 2:
        N = np.array([(0.5*z**2 - 0.5*z), (0.5*z**2 + 0.5*z), (1-z**2) ])
        jac = np.array([z-0.5, z+0.5, -2*z])@xe
        dN_dx = np.array([z-0.5, z+0.5, -2*z])/jac

        return N, dN_dx, jac

    if order == 3:
        N = np.array([-6/19*(z+1/3)*(z-1/3)*(z-1), 6/19*(z+1/3)*(z-1/3)*(z+1), 27/16*(z+1)*(z-1/3)*(z-1), -27/16*(z+1)*(z+1/3)*(z-1)])
        jac = np.array([-2/57*(27*z**2 - 18*z -1), 2/57*(27*z**2 + 18*z -1), 9/16*(9*z**2 - 2*z - 3), -9/16*(9*z**2 + 2*z - 3)])@xe
        dN_dx = np.array([-2/57*(27*z**2 - 18*z -1), 2/57*(27*z**2 + 18*z -1), 9/16*(9*z**2 - 2*z - 3), -9/16*(9*z**2 + 2*z - 3)])/jac

        return N, dN_dx, jac


def ke_fun(E, A, nen, dN_dx)
    ke = np.zeros((nen, nen))

